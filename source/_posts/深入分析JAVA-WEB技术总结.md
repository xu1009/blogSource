---
title: 深入分析JAVA WEB技术总结
date: 2017-07-15 07:47:36
tags: java web
---
##### DNS解析过程
* 最先在浏览器缓存里面找
* 本地操作系统缓存
* 本地域名服务器
* 根服务器
* 解析完成之后会自动缓存这个结果
##### 域名解析方式
* A记录,指定URL所对应的IP地址
* MX记录,将某个地址下的邮件服务器指向自己的mail server
* CNAME记录,别名解析,为一个域名设置很多别名
* NS记录,为某个域名指定DNS解析服务器
* TXT记录,为域名设置说明
##### JAVA IO
* 基于字节的IO,基于字符的,基于磁盘的,基于网络的.
* 字节到字符需要解码,字符到字节需要编码,很透彻
* 所以在读取文件或者写入文件的时候需要指定编码解码方式,不指定就使用系统默认的编解码方式
##### 文件访问方式
* 标准IO访问,调用操作系统操作文件的方法,这里涉及到高速缓存.
* 直接IO访问,不经过高速缓存,直接访问磁盘,这样会比较慢
* 同步IO,就是阻塞式的IO,必须等到读取或者写入完成之后,才能做其他事情
* 异步IO,非阻塞式,读取和写入时,当前线程不必等待,可以去处理其它事情.
* 内存映射,将磁盘一段内存空间映射到用户缓存空间,这样访问,
##### 同步 异步  阻塞  非阻塞
* 同步就是一个任务序列的完成需要依赖另外一个任务时,只有等待被依赖的任务完成之后,依赖的任务才能完成,这是一种可靠的任务序列.
* 异步是不可靠的任务序列,他不必等待被依赖的任务完成,只是通知被依赖的任务要完成什么样的工作.
* 同步能够保证程序的可靠行,异步可以提升程序的性能,必须在可靠性和性能之间保持平衡.
* 阻塞是CPU停下来等待一个慢动作完成之后,才能执行其它任务.
* 非阻塞是CPU没必要停下来,非阻塞明显提高了CPU的利用率,带来的坏处就是线程之间的切换带来的开销.
### 编码问题相关
* 通俗的讲,计算机存储的基本单元是英语,其它语言必须通过一次翻译,翻译成英语才能和计算机通信,这叫做编码.
##### 一些编码方式简述
* ASCLL码,总共有128个,用一个字节的低7位表示,0-31表示换行 回车这些,32-126表示打印字符,可以通过键盘输入并且能够显示出来.
* ISO-8859-1仍然是单字节编码,主要是用来弥补ASCLL码的不足,加了一些西欧语言字符,应用的十分广泛,总共有256个字节.
* GB2312 中文编码字符集,使用双字节编码,就是比较少,才6000多个汉字.
* GBK和GB2312兼容,增加了很多汉字,相当于GB2312的拓展,而且两者是兼容的.
* GB18030 国家标准,但是用的不多.
* UTF-16使用定长表示方法,不论什么字符都使用两个字节表示.
* UTF-8采用变长编码,utf-16虽然在表示上非常方便,但是有些字符只需要一个字节表示就够了,没必要使用两个字节表示,所以这样就造成内存空间的的增大,十分不方便,UTF-8使用1-6个字节组成,
* 编码,解码问题主要是从字节到字符或者字符到字节的过程,Java内存使用的时utf-16编码,utf-16编码简单高效,utf-8多用于网络编码,节省流量,utf-16是顺序编码,这样会导致中间一个字节码坏掉之后影响之后的,而utf-8则不会,它会对单个字符进行校验,所以可靠性更高.
#### Java web中的编码和解码问题
* 首先网络中传输使用的是http协议,也就是socket,socket流是字节流,所以,要想在网络中传输,首先需要编码,从网络中获取到字节流之后再进行解码还原成我们需要的那种.
* URI和QueryString的编解码还不一样,tomcat处理这个URL时,就是要解码,uri就是使用配置文件中的解码方式,connector中的URIEncoding决定了解码方式,queryString的话就是基本上按照header中的content type来解码的,需要配置tomcat中的useBodingEncodingForUri为true.
* tomcat在解析post方式的表单数据时,解码方式是要按照header中的content type里面的charset属性,如果请求头中没有包含该属性的话,则会按照默认的iso-8859-1进行解码,如果提交的数据包含非ASCLL码的话就会出现乱码的现象.
* 返回给浏览器的数据也需要编码,浏览器根据,response中的header  charset进行解码的,如果没有这个响应头的话就按照HTML中指定的charset进行解码,如果仍然没有的话就按照默认的解码方式.
#### Cookie and Session
* 其实这个没啥讲的，这个用的比较多的是在集群条件下的共享问题，session本质还是cookie，一种特殊的cookie，jsessionid = value
value是session的id，服务端会根据这个id去找session对象，这样就可以在传输中节省了大量带宽，传输的只是id了，而且安全性比cookie高，cookie还就是在客户端存储有限制，但是session在服务端集群的条件下存在共享的问题，各有好处，现在用的都是分布式缓存来存储session，有一个订阅服务器去管理，这样就将存储和管理从服务器分离，减少了服务器的负担，可以有效控制session的安全性和cookie的数量。
